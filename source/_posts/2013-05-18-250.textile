---
layout: post
title: '三言两语聊kernel：线程栈'
date: 2013-5-18
wordpress_id: 250
permalink: /blogs/250
comments: true
---
Oops! MacOS不支持proc文件系统，这或许是BSD系统最值得吐槽的地方吧。无奈只好到linux机器上写了这篇文章。

下面是一个比较简单的多线程程序。程序如下，

<a href="http://www.laoar.net/wp-content/uploads/2013/05/prog.png"><img class="aligncenter size-full wp-image-252" title="prog" src="http://www.laoar.net/wp-content/uploads/2013/05/prog.png" alt="" width="484" height="458" /></a>

上图是我的测试程序，我创建了3个线程。程序运行以后，我们可以通过/ proc/PID/task来看该程序有多少线程在运行：

<a href="http://www.laoar.net/wp-content/uploads/2013/05/task.png"><img class="aligncenter size-full wp-image-253" title="task" src="http://www.laoar.net/wp-content/uploads/2013/05/task.png" alt="" width="272" height="56" /></a>

然后我们来看一下进程的地址空间。 /proc/PID/maps就是进程的地址空间。如下所示：

<a href="http://www.laoar.net/wp-content/uploads/2013/05/maps.png"><img title="maps" src="http://www.laoar.net/wp-content/uploads/2013/05/maps.png" alt="" width="533" height="368" /></a>

可以看出，进程的地址空间从低到高依次是：进程代码段(标志含有x)、只读数据段、可读写数据段、堆、栈（包括动态库的栈空间）。
<div>
<div>    线程83438的栈：0xb7570000 - 0xb6d70000的值恰好是8M，线程栈默认大小是8M。0xb6d70000 - 0xb6d6f000的值是1K，这1K是保护页。</div>
<div>    为什么这三个线程的栈都是8M？可以从ulimit命令来得出，这是进程的资源限制：</div>
<div><a href="http://www.laoar.net/wp-content/uploads/2013/05/ulimit.png"><img class="aligncenter size-full wp-image-254" title="ulimit" src="http://www.laoar.net/wp-content/uploads/2013/05/ulimit.png" alt="" width="336" height="254" /></a></div>
<div>    使用ulimit -a命令可以看出，进程资源限制中栈大小的限制是8194K，即8M。</div>
<div>     那么，这个8M大小是不是可以更改的？以及后面会什么会有一个4K大小的保护页？这可以从glibc代码里面来获取答案：</div>
<div>
<div></div>
<div>       <strong><span style="color: #808000;">  1. </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">__pthread_create_2_1</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        /*<a><span style="color: #808000;">这里分配线程栈</span></a>*/</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        ALLOCATE_STACK (iattr, &amp;pd); </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">2. </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">allocate_stack就是具体的分配线程栈的函数：</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">allocate_stack</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     <a><span style="color: #808000;">/*如果没有设置线程栈大小，就使用默认值</span></a>*/</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     size = attr-&gt;stacksize ?: __default_stacksize;     </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     ...</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      /* Try to get a stack from the cache.  */</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      pd = get_cached_stack (&amp;size, &amp;mem);</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     /*如果没有从cache申请到，就要mmap申请一块内存*/</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      if (pd == NULL){</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">           /*MAP_PRIVATE | MAP_ANONYMOUS：私有匿名映射*/</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">          mmap (NULL, size, prot,  </span></strong></div>
<p style="padding-left: 120px;"><strong><span style="color: #808000;">MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);   </span></strong></p>

<div style="padding-left: 30px;"><strong><span style="color: #808000;">      }</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     /*</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        接着设置一个保护区，该区域的页表属性是PROT_NONE,</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        即Page can not be accessed</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     */</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      mprotect (guard, guardsize, PROT_NONE) </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;"> </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">       对于设置为PROT_NONE的页，是不能访问的，那么访问到这个保护区时就出现错误，linux是靠这种机制来实现栈溢出保护的。</span></strong></div>
<div style="padding-left: 30px;"></div>
<div><span style="color: #000000;">    下面我们来调整线程栈：</span></div>
<div><span style="color: #000000;">   <strong> 1. 设置pthread_attr属性</strong></span></div>
</div>
<div><a href="http://www.laoar.net/wp-content/uploads/2013/05/Image.png"><img class="aligncenter size-full wp-image-255" title="Image" src="http://www.laoar.net/wp-content/uploads/2013/05/Image.png" alt="" width="530" height="171" /></a></div>
<div></div>
<div><a href="http://www.laoar.net/wp-content/uploads/2013/05/new.png"><img class="aligncenter" title="new" src="http://www.laoar.net/wp-content/uploads/2013/05/new.png" alt="" width="515" height="115" /></a></div>
<div>
<div>可以看到此时的线程栈大小是： 0xb758f000 - 0xb756f000 = 128K.</div>
</div>
<div>    <strong>2.通过ulimit来统一设置当前shell下将要执行的程序的线程栈 </strong></div>
<div>        ulimit -s  128</div>
<div>
<div>    要注意的是， ulimit -s是针对shell的设置， 即只对当前shell fork的进程有效。如果在另外一个shell上起进程，则是没有效果的。参见 man手册：“Control the resources available to a process started by the shell, on systems that allow such control.”</div>
</div>
<div></div>
</div>
