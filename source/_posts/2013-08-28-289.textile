---
layout: post
title: '三言两语聊Kernel：do{…}while(0)'
date: 2013-8-28
wordpress_id: 289
permalink: /blogs/289
comments: true
---
在内核代码里我们会看到很多do{…}while(0)来定义的宏，比如(摘自include/asm-generic/barrier.h)：

<a href="http://www.laoar.net/wp-content/uploads/2013/08/a1a55542c1df74438a4752b24202c7ab.png"><img class="aligncenter size-full wp-image-290" title="a1a55542c1df74438a4752b24202c7ab" src="http://www.laoar.net/wp-content/uploads/2013/08/a1a55542c1df74438a4752b24202c7ab.png" alt="" width="683" height="45" /></a>linux kernel里这么定义自然有其特殊的目的。

在C语言里，使用do/while(0)模式来定义的宏在任何情况下都有同样的行为，而且在C语言里面，只有do/while(0)模式来定义的宏才会在任何情况下(比如，在没有“ }”的if语句中)都有同样的行为.

举一些例子。

<span style="line-height: 1.5;">     <span style="color: #993300;">＃define foo(x)  a(x); b(x)</span></span>

对于 <span style="color: #993300;">foo(test);
</span>会被展开为： <span style="color: #993300;">a(test); b(test);</span>

&nbsp;

如果是这样的话，这看起来很正确，没有任何错误，是你原本想要得到的结果。

但如果这样用：
<span style="color: #993300;">     if (cond)
</span><span style="color: #993300;">         foo(test);
</span>    它就会被展开为：
<span style="color: #993300;">    if (cond)</span>
<span style="color: #993300;">        a(test); b(test);
</span>    它的行为就变成了：
<span style="color: #993300;">    if (cond)          </span>
<span style="color: #993300;">        a(test); </span>
<span style="color: #993300;">     b(test);
</span>    这并不是你原本想要的。

然后，我们重新定义该宏，使用do/while(0)来封装：
<span style="color: #993300;"> ＃define foo(x) do{a(x); b(x)}while(0)</span>

这样定义的宏和前面定义的宏具有同样的作用，只不过，do确保了它的整个逻辑都在大括号里面执行，while(0)确保它只执行一次。所以它跟没有do/while(0) 的宏具有同样的效果。那么，他们有什么不同吗？让我们再来看前面那个例子：
<span style="color: #993300;">    if (cond)          </span>
<span style="color: #993300;">        foo(test);
</span>    现在它就变成了：
<span style="color: #993300;">    if(cond)</span>
<span style="color: #993300;">        do{a(test); b(test)}while(0);
</span>    实际上就是：
<span style="color: #993300;">    if(cond){</span>
<span style="color: #993300;">        a(test);</span>
<span style="color: #993300;">        b(test);</span>
<span style="color: #993300;">    }</span>

你可能会疑问，为什么不直接使用“{}”来定义该宏？让我们来看下面这种情况：
<span style="color: #993300;">#define foo(x) {a(x); b(x);}</span>
那么：
<span style="color: #993300;">    if(cond)</span>
<span style="color: #993300;">        foo(test);</span>
<span style="color: #993300;">    else</span>
<span style="color: #993300;">        bin(test);</span>
就变成了：
<span style="color: #993300;">    if(cond){</span>
<span style="color: #993300;">        a(test);</span>
<span style="color: #993300;">        b(test);</span>
<span style="color: #993300;">    };</span>
<span style="color: #993300;">    else</span>
<span style="color: #993300;">        bin(test);
</span>    显然这是一个语法错误，因为else前面没有if。

使用这种方式来定义宏，还有个好处是，在"{...}"里面可以定义自己的局部变量，而不被外面的变量所干扰。

在linux内核代码里，很多宏都是使用do/while(0)来封装的，目的就是为了让它在任何情况下都具有同样的行为。在我们自己的代码里，也要养成这种好习惯。

&nbsp;

&nbsp;
