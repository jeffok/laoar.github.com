
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>为什么发送segment fault信号的进程总是PID0 ？ - The Complaint of laoar</title>
  <meta name="author" content="Yafang Shao">

  
  <meta name="description" content="让我们先来看一个小程序。
这个小程序的大概意思就是，注册了一个segmentation fault的handler， 在该handler里把SIGSEGV信号的一些信息打印出来，我这里打印了两个值，一个是进程自身的PID，另外一个是info-&gt;si_pid, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://laoar.github.io/blogs/435">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="The Complaint of laoar" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The Complaint of laoar</a></h1>
  
    <h2>纯属歪歪</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:laoar.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">为什么发送segment fault信号的进程总是PID0 ？</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-15T00:00:00+08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2014</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://laoar.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>让我们先来看一个小程序。</p>
<p><a href="http://www.laoar.net/wp-content/uploads/2014/02/1.png"><img class="aligncenter size-full wp-image-436" alt="1" src="http://www.laoar.net/wp-content/uploads/2014/02/1.png" width="766" height="566" /></a>这个小程序的大概意思就是，注册了一个segmentation fault的handler， 在该handler里把SIGSEGV信号的一些信息打印出来，我这里打印了两个值，一个是进程自身的PID，另外一个是info-&gt;si_pid, Linux内核里对它的解释是发送信号的进程的PID。</p>
<p>来看下它的执行结果：</p>
<p><a href="http://www.laoar.net/wp-content/uploads/2014/02/2.png"><img class="aligncenter size-full wp-image-438" alt="2" src="http://www.laoar.net/wp-content/uploads/2014/02/2.png" width="298" height="50" /></a>我们可以看到当前进程的PID是1060，info-&gt;si_pid的值则是0。</p>
<p>我们看下&lt;sys/signal.h&gt;对si_pid的解释，</p>
<p><a href="http://www.laoar.net/wp-content/uploads/2014/02/3.png"><img class="aligncenter size-full wp-image-439" alt="3" src="http://www.laoar.net/wp-content/uploads/2014/02/3.png" width="679" height="266" /></a>这里清清楚楚的写的是，sending process，即发送该信号的进程ID。</p>
<p>于是，问题就来了，为什么SIGSEGV信号的发送进程是PID0 哪？</p>
<p>我们从头来理一下Kernel对signal的处理机制， 以我们前面这个小程序为例。</p>
<p>在我们的程序里，Line 17定义了一个指针p并初始化为NULL，接着在Line 22对p指向的内容赋值为1，我们都已经知道对空指针解引用会导致segment fault。那么，segment fault具体是怎么产生的？</p>
<p>Kernel为了提高App的执行效率采取的是惰性分配机制，即只有在第一次写的时候才会给它分配具体的物理内存。那么在Line 22由于还没有为指针p分配物理内存，所以这里会首先产生一个缺页异常(page fault), 通过缺页异常陷入内核，接着执行内核的缺页异常处理流程。在内核缺页异常处理流程里，它判断出这是一个用户态的缺页异常，于是就尝试该缺页异常是否可以通过一些手段来解决掉。很遗憾的是，由于没给p申请内存空间，所以p不属于合法的vma区域，即所谓的bad area。于是就产生一个SIGSEGV信号给我们的这个进程。于是异常流程就执行完毕了，开始返回用户态。在返回用户态之前，进程会判断是否有信号需要处理。由于在之前产生了一个SIGSEGV信号，所以又去执行SIGSEGV的信号处理流程了，注意此时已然是在user land来执行了。SIGSEGV的默认处理流程是产生一个segment fault，并且生成一个core文件。由于我们这个程序自己注册了一个SIGSEGV的信号处理程序void handler (int sig, siginfo_t *info, void *ctx), 从内核态返回后就开始执行这个handler函数。 在信号处理程序结束后，如果没有让程序退出，即没有那个exit(-1), 那么就返回到我们程序产生异常的地方，即Line 22，继续执行（PS : 这就是为什么如果没有这个exit，该程序就会死循环的原因）。 这就是Line 22这个语言在内核里的一些动作。</p>
<p>从我们的这个分析可以看出，应该不关PID0鸟事才会。可是事实现实，PID0确实插了一脚，很困惑不是，它到底插在哪儿了哪？</p>
<p>唯一的可能之处就是SIGSEGV产生的地方。我们打开Kernel代码来看看这里到底发生了什么。</p>
<p><a href="http://www.laoar.net/wp-content/uploads/2014/02/4.png"><img class="aligncenter size-full wp-image-440" alt="4" src="http://www.laoar.net/wp-content/uploads/2014/02/4.png" width="549" height="275" /></a><span style="line-height: 1.5em;">这一小段代码就是SIGSEGV产生的地方。可以看到这里对info的si_signo/si_error/si_addr进行了赋值，在前面还对si_code进行了赋值，即SIGSEGV信号只用到了这四个字段。 也就是说，对于SIGSEGV而言，si_pid啥意义都没有。 </span></p>
<p>我们可以对比看下SIGKILL这个信号。</p>
<p><a href="http://www.laoar.net/wp-content/uploads/2014/02/5.png"><img class="aligncenter size-full wp-image-441" alt="5" src="http://www.laoar.net/wp-content/uploads/2014/02/5.png" width="770" height="262" /></a></p>
<p>可以看到在产生SIGKILL的地方，将当前的活动进程赋值给了si_pid, 这也是我们在终端里按下CRTL+C来杀死一个进程的原理。接受键盘输入的进程(bash进程)给目标进程发送了一个SIGKILL信号，然后就把目标进程干掉了。</p>
<p>想了并研究了这么一段时间，却得出了这么一个结论（对SIGSEGV而言，si_pid没有任何意义也就没处理），表示很失望，Kernel工程师能够再爱岗敬业一些么？ 至少把那句注释“sending process”改称“sending process(if needed)” 也好么，至少不会引起太多的误解。</p>
<p>&nbsp;</p>
<p>PS. : 写完一看字数，又是1000字，看来很适合写千字文。不深不浅聊技术，千字文是也。</p></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Yafang Shao</span></span>

      








  


<time datetime="2014-02-15T00:00:00+08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <span>
  <iframe 
    width="86" 
    scrolling="no" 
    height="16" 
    frameborder="0" 
    src=
      "http://hits.sinajs.cn/A1/weiboshare.html?url=http://laoar.github.io/blogs/435&amp;type=6&amp;language=zh_cn" allowtransparency="true">
  </iframe>
  </span>
  
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blogs/422" title="Previous Post: 我的2013">&laquo; 我的2013</a>
      
      
        <a class="basic-alignment right" href="/blogs/455" title="Next Post: 关于Profiling">关于Profiling &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/05/25/hello-github/">Hello Github</a>
      </li>
    
      <li class="post">
        <a href="/blogs/501">性能优化：一些很有意思的尝试</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/20/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/blogs/482">从linux内核里来学习性能优化，和一个例子</a>
      </li>
    
      <li class="post">
        <a href="/blogs/466">关于struct Hack, 优雅的FreeBSD</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Yafang Shao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'laoar';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://laoar.github.io/blogs/435';
        var disqus_url = 'http://laoar.github.io/blogs/435';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
