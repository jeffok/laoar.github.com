
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>One Man's Yammer</title>
	<meta name="author" content="Yafang Shao">

	
	<meta name="description" content="在内核代码里我们会看到很多do{…}while(0)来定义的宏，比如(摘自include/asm-generic/barrier.h)： linux kernel里这么定义自然有其特殊的目的。
在C语言里，使用do/while(0)模式来定义的宏在任何情况下都有同样的行为，而且在C语言里面， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="One Man's Yammer" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">One Man's Yammer</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/read">BookWall</a></li>
</ul>
</nav>
<nav id="mobile-nav"> <ul class="main">
	<li><a href="/read">BookWall</a></li>
</ul>
 </nav>
<!--	<div class="menu"> --!>
		<!--<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/read">BookWall</a></li>
</ul>
</div>--!>
	<!--</div>--!>
<!--</nav>--!>
<!-- @yfshao
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="false" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:laoar.github.io">
			</form>
		</div>
	</div>
</nav>
--!>
<!--
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="false" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:laoar.github.io">
	</form>
</nav>
--!>
<!----!>
</header>
	
		
	
	<div id="content" class="inner"><meta content="width=device-width,user-scalable=no" name="viewport">





    
    
	<section class="archives">
		<h1 class="year">2014</h1>

		<article>
    		<a href="/blog/2014/12/27/reading-2014/">My Reading in 2014</a>
		</article>
    




		<article>
    		<a href="/blog/2014/11/26/loop-unrolling/">loop unrolling : may or may not make the program run faster</a>
		</article>
    




		<article>
    		<a href="/blog/2014/08/31/ruby/">Ruby, 我的书有点乱</a>
		</article>
    




		<article>
    		<a href="/blog/2014/07/13/jin-ji-de-ccheng-xu-yuan/">进击的C程序员, Ruby, 豆瓣读书</a>
		</article>
    




		<article>
    		<a href="/blog/2014/06/24/ldscript/">性能优化，要懂点编译原理</a>
		</article>
    




		<article>
    		<a href="/blog/2014/05/25/hello-github/">Hello Github!</a>
		</article>
    




		<article>
    		<a href="/blogs/501">性能优化：一些很有意思的尝试</a>
		</article>
    




		<article>
    		<a href="/blogs/482">性能优化，从linux内核里来学习，和一个例子</a>
		</article>
    




		<article>
    		<a href="/blogs/466">关于struct hack, 优雅的FreeBSD</a>
		</article>
    




		<article>
    		<a href="/blogs/455">性能优化,关于Profiling</a>
		</article>
    




		<article>
    		<a href="/blogs/435">为什么发送segment fault信号的进程总是PID0 ？</a>
		</article>
    




		<article>
    		<a href="/blogs/422">我的2013</a>
		</article>
    




    
    
    
	<section class="archives">
		<h1 class="year">2013</h1>

		<article>
    		<a href="/blogs/402">MacOS:mdworker曾让我很不爽</a>
		</article>
    




		<article>
    		<a href="/blogs/393">我为什么从华为离职</a>
		</article>
    




		<article>
    		<a href="/blogs/367">三言两语聊Kernel：linux kernel和bsd kernel实现doubly-linked list的差异</a>
		</article>
    




		<article>
    		<a href="/blogs/361">三言两语聊Kernel：atomic </a>
		</article>
    




		<article>
    		<a href="/blogs/338">三言两语聊Kernel：该怎么理解Terminal</a>
		</article>
    




		<article>
    		<a href="/blogs/325">三言两语聊Kernel：从Linux到FreeBSD</a>
		</article>
    




		<article>
    		<a href="/blogs/316">在高铁上聊Kernel：what is the fucking ABI(程序二进制接口)?</a>
		</article>
    




		<article>
    		<a href="/blogs/299">三言两语聊Kernel：Busy Waiting or Sleeping？</a>
		</article>
    




		<article>
    		<a href="/blogs/289">三言两语聊Kernel：do{…}while(0)</a>
		</article>
    




		<article>
    		<a href="/blogs/269">三言两语聊kernel：调度入门</a>
		</article>
    




		<article>
    		<a href="/blogs/266">三言两语聊kernel：内存管理入门</a>
		</article>
    




		<article>
    		<a href="/blogs/250">三言两语聊kernel：线程栈</a>
		</article>
    




		<article>
    		<a href="/blogs/227">2012 memory</a>
		</article>
    




		<article>
    		<a href="/blogs/215">三言两语聊Kernel： Undefined Instruction</a>
		</article>
    




    
    
    
	<section class="archives">
		<h1 class="year">2012</h1>

		<article>
    		<a href="/blogs/197">三言两语聊Kernel：flash驱动及文件系统</a>
		</article>
    




		<article>
    		<a href="/blogs/180">《捉虫日记》书评</a>
		</article>
    




		<article>
    		<a href="/blogs/119">iPhoneOS浅浅浅浅析(4):不做学术派</a>
		</article>
    




		<article>
    		<a href="/blogs/112">iPhoneOS浅浅浅浅析（3）</a>
		</article>
    




		<article>
    		<a href="/blogs/91">iPhoneOS浅浅浅浅析（2）</a>
		</article>
    




		<article>
    		<a href="/blogs/79">iPhoneOS浅浅浅浅析</a>
		</article>
    




		<article>
    		<a href="/blogs/66">是闰土，还是马克？</a>
		</article>
    




		<article>
    		<a href="/blogs/3">hello world!</a>
		</article>
    
	</section>
    

<!--    <h4 class="title"><a href=""></a></h4>
&#8211;>
<!--



   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/289">
		
			三言两语聊Kernel：do{…}while(0)</a>
	</h2>
	<div class="entry-content">
		<p>在内核代码里我们会看到很多do{…}while(0)来定义的宏，比如(摘自include/asm-generic/barrier.h)：<br />
<img src="/images/289.jpg"><br />
linux kernel里这么定义自然有其特殊的目的。</p>
<p>在C语言里，使用do/while(0)模式来定义的宏在任何情况下都有同样的行为，而且在C语言里面，只有do/while(0)模式来定义的宏才会在任何情况下(比如，在没有“ }”的if语句中)都有同样的行为.</p>
<p>举一些例子。</p>
<p><span style="line-height: 1.5;">     <span style="color: #993300;">＃define foo(x)  a(x); b(x)</span></span></p>
<p>对于 <span style="color: #993300;">foo(test);<br />
</span>会被展开为： <span style="color: #993300;">a(test); b(test);</span></p>
<p>&nbsp;</p>
<p>如果是这样的话，这看起来很正确，没有任何错误，是你原本想要得到的结果。</p>
<p>但如果这样用：<br />
<span style="color: #993300;">     if (cond)<br />
</span><span style="color: #993300;">         foo(test);<br />
</span>    它就会被展开为：<br />
<span style="color: #993300;">    if (cond)</span><br />
<span style="color: #993300;">        a(test); b(test);<br />
</span>    它的行为就变成了：<br />
<span style="color: #993300;">    if (cond)          </span><br />
<span style="color: #993300;">        a(test); </span><br />
<span style="color: #993300;">     b(test);<br />
</span>    这并不是你原本想要的。</p>
<p>然后，我们重新定义该宏，使用do/while(0)来封装：<br />
<span style="color: #993300;"> ＃define foo(x) do{a(x); b(x)}while(0)</span></p>
<p>这样定义的宏和前面定义的宏具有同样的作用，只不过，do确保了它的整个逻辑都在大括号里面执行，while(0)确保它只执行一次。所以它跟没有do/while(0) 的宏具有同样的效果。那么，他们有什么不同吗？让我们再来看前面那个例子：<br />
<span style="color: #993300;">    if (cond)          </span><br />
<span style="color: #993300;">        foo(test);<br />
</span>    现在它就变成了：<br />
<span style="color: #993300;">    if(cond)</span><br />
<span style="color: #993300;">        do{a(test); b(test)}while(0);<br />
</span>    实际上就是：<br />
<span style="color: #993300;">    if(cond){</span><br />
<span style="color: #993300;">        a(test);</span><br />
<span style="color: #993300;">        b(test);</span><br />
<span style="color: #993300;">    }</span></p>
<p>你可能会疑问，为什么不直接使用“{}”来定义该宏？让我们来看下面这种情况：<br />
<span style="color: #993300;">#define foo(x) {a(x); b(x);}</span><br />
那么：<br />
<span style="color: #993300;">    if(cond)</span><br />
<span style="color: #993300;">        foo(test);</span><br />
<span style="color: #993300;">    else</span><br />
<span style="color: #993300;">        bin(test);</span><br />
就变成了：<br />
<span style="color: #993300;">    if(cond){</span><br />
<span style="color: #993300;">        a(test);</span><br />
<span style="color: #993300;">        b(test);</span><br />
<span style="color: #993300;">    };</span><br />
<span style="color: #993300;">    else</span><br />
<span style="color: #993300;">        bin(test);<br />
</span>    显然这是一个语法错误，因为else前面没有if。</p>
<p>使用这种方式来定义宏，还有个好处是，在&quot;{&#8230;}&quot;里面可以定义自己的局部变量，而不被外面的变量所干扰。</p>
<p>在linux内核代码里，很多宏都是使用do/while(0)来封装的，目的就是为了让它在任何情况下都具有同样的行为。在我们自己的代码里，也要养成这种好习惯。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-08-28T00:00:00+08:00" pubdate data-updated="true">Aug 28<span>th</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/269">
		
			三言两语聊kernel：调度入门</a>
	</h2>
	<div class="entry-content">
		<p>前言</p>
<p>前面说了内存管理入门， 内存管理是理解linux内核的基础， 如果不了解内存管理，就无法深入了解内核，理解了内存管理，再学习内核的其他部分就会相对很容易。</p>
<p>这次我要说的是调度这部分， 调度在嵌入式系统中也是一个很重要的方面，众所周知，嵌入式系统对实时性要求较高， 实时性本身就是一个调度问题。</p>
<p>&nbsp;</p>
<p><strong>一 进程调度的目的</strong></p>
<p>linux进程调度是为了支持多进程，如果只是单一进程，显然是不需要调度的。 在对多进程的支持过程中， 如何合理的分配系统资源是进程调度要解决的问题，主要包括cpu该选择哪一个进程执行以及让该进程一次执行多长时间，另外一个就是smp系统的负载均衡， 即如何提高多核系统的并行执行性能。</p>
<p>进程调度是针对task_running状态的进程进行调度， 如果进程不处于task_running状态，进程调度跟它就是没有关系的。 于是就引入了进程状态这个概念。</p>
<p><strong>二 进程状态</strong></p>
<p>进程状态分为task_running状态／睡眠状态／task_stop状态／僵死状态。</p>
<p>task_running状态就是可以被调度的状态，内核在调度点都是选择运行队列上的一个进程来执行。</p>
<p>睡眠状态分为两种：不可中断状态（R状态）和可中断状态（S状态），一般是进程在运行状态想获得某一个资源但是暂时又得不到，那么该进程就会进入睡眠状态，在条件成立的时候再唤醒该进程，唤醒的方式一般都是通过wake_up系列函数来唤醒。 对于S状态的进程，它还可以被信号给唤醒。</p>
<p>task_stop状态是指正在运行的状态收到了sig_stop等一些信号而进入暂停状态， 这可以通过sig_continue信号来将其唤醒。</p>
<p>僵死状态： 当进程已经停止运行，但是其父进程还没有读取该子进程的exit状态时，它的task_struct就会驻留在内存中形成了僵死进程。僵死进程的解决方法是：一是让父进程来waitpid来接管sigchld信号，二是 结束它的父进程，让init进程来处理。 产生的原因：如果父进程fork子进程时没有处理sigchld这个信号， 就会形成僵死进程,有时候可能网络原因等也会产生僵死进程。</p>
<p><strong>三 进程调度点</strong></p>
<p>进程有用户态和内核态这两个状态， 即它有两个栈空间，分别时用户栈空间和内核栈空间。 在内核态下和用户态下都可以发生调度，内核态的调度发生在从中断上下文返回到内核态之前（即进程被中断打断了，中断处理完要返回的时候）， 用户态的调度发生在从内核态返回到用户态的时候（即从系统调用返回的时候。）。  内核态的调度需要打开内核抢占，如果不支持内核抢占，在内核态是不会发生调度的。</p>
<p>ok， 接下来要搞清这个问题。假如我一个进程正在处于用户态，突然来了个中断，会发生什么？ 这个时候，cpu会从特权级3进入特权级0, 进程会由用户态切换到内核态（即从用户态的栈切换到内核态的栈），用户态堆栈指针会压入内核堆栈，中断执行完，首先返回到内核态，然后在从内核态返回到用户态的时候会恢复用户态堆栈。</p>
<p><strong>四 进程的调度策略</strong></p>
<p>进程按照其优先级分为实时进程和普通进程。</p>
<p>实时进程的优先级较高， 实时进程又有两种调度策略：一个时FIFO，另一个是RR。对于FIFO进程而言，只有它执行完，才会选择其他进程执行（没有流控的情况下），而对于RR进程， 则是时间片轮转策略。</p>
<p><strong>五 抢占</strong></p>
<p>linux内核抢占需要在menuconfig里面打开config_preempt选项。</p>
<p>用户抢占则是天生就可以的， 如果不可以， 那怎么支持多进程涅：）</p>
<p><strong>六 从用户态进入内核态的情况</strong></p>
<p>1. 系统调用</p>
<p>2. 异常指令（其实系统调用也是一个异常指令）</p>
<p>3. 中断</p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-07-29T00:00:00+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/266">
		
			三言两语聊kernel：内存管理入门</a>
	</h2>
	<div class="entry-content">
		<p style="text-align: left;">前言</p>
<p style="text-align: left;">最近稍有闲暇将自己的一些所学做了整理， 只是浅显的说个大概，没有往细了说，观题目就可知，仅作入门：）</p>
<p><strong>1. 内存管理的目的</strong></p>
<p>由于计算机系统所含的实际物理内存大小是有限的， 所以CPU中通常都提供了内存管理机制来对系统中的内存进行有效的管理。 再intel CPU中， 提供了两种内存管理机制： 分段机制 和 分页机制。</p>
<p>分页管理系统是可以选择的， 它有menuconfig的配置来决定是否需要分页。</p>
<p>对于linux内核而言，它并没有使用intel CPU的分段机制， 而只是采用了它的分页机制。</p>
<p>内存管理的一个目的是地址变换，另外一个目的是寻址保护。</p>
<p><strong>2. 分页机制主要明白以下概念：</strong></p>
<p>虚拟地址，物理地址， 页，page 结构体。</p>
<p>对于进程而言， 它看到的都是虚拟地址空间， 在32bit CPU上，它的地址空间是4G；</p>
<p>对于CPU而言，它访问的是具体的物理内存，即物理地址空间。</p>
<p>如果由进程的虚拟机制空间来转换为CPU的物理地址空间，就有了MMU这个单元，它的作用是将虚拟地址空间映射为物理地址空间。映射方式就是采用的分页机制，首先将实际物理内存按照4K大小为单位来将物理内存划分为一个个物理页框，这些物理页框通过page结构体来索引， 所有的物理page都是通过一个字节数组mem_map[]来进行检索，该数组的每一个元素代表一个物理page的状态。 mem_map[]对于numa和uma，sparse memory和flat memroy这些内存管理模型上具有不同的实现。 numa是基于节点的， sparse memory是基于section的。</p>
<p>在地址变换的过程中，首先由虚拟地址的前12bit得出起PGD，结合PGD的内容和CP15寄存器计算出其PMD的基址，虚拟地址的中间8bit为其偏移，然后通过PMD里面的内容计算出PTE的基址（即物理页框的地址），虚拟地址的最后12bit是PTE的偏移，这个地址就是该虚拟地址对应的物理内存的地址。</p>
<p><strong>3. 虚拟地址空间的划分</strong></p>
<p>进程的地址空间分为内核空间和用户空间两部分。 这两部分的比例可以通过menuconfig来进行配置， 一般都是配置为1：3,即用户空间占3G， 内核空间占1G。</p>
<p>用户空间是0～3G这部分地址， 内核空间是3G～4G这部分地址。 对于用户空间而言，每个进程都有自己的页表，而内核空间则只有一份页表（中断／内核线程这些只运行在内核空间的都是没有mm_struct的）。</p>
<p>内核空间是如下划分：</p>
<p>内核空间起始于PAGE_OFFSET（即3G）， 在开始的区域是nomal memory区域，这部分区域包括内核镜像／mem_map[]数组，normal memory区域是线性映射， 它映射到物理内存的起始部分。</p>
<p>然后从high–memory这个地方开始就是所谓的高端内存， 在高端内存和normal memory之间有一个4K的保护页，它的主要作用是起到保护作用。</p>
<p><strong>4. 高端内存</strong></p>
<p>高端内存主要是为了解决线性地址不够用的问题。 高端内存有三种映射方式： 固定映射／永久映射／临时映射以及非连续物理地址映射。</p>
<p>非连续物理地址映射即vmalloc区域，它从VMALLOC_START到VMALLOC_END 这个区域，它的意思是线性地址是连续的，但是映射的物理地址未必是连续的，这部分空间是通过vmalloc（）来申请。</p>
<p>再往后是永久映射，就是所谓的pmap区域，它通过pmap（）来申请， 通过punmap（）来释放。</p>
<p>再往后是固定映射区， 它从fixed_addr_start开始，到fixed_addr_top结束，固定映射一般都是在编译阶段就确定好一些外设的映射关系，在系统启动阶段建立好它的映射关系后便不会在改变， 它的目的主要是解决一些外设在boot阶段就需要建立好映射的情况，一般都是用一个数学公式来表示它的映射。 都有哪些设备会用到固定映射？？ 例如中断控制器就是采用固定映射，中断入口地址就是在编译阶段确定的，对于arm而言是0xffff0000。</p>
<p>在固定映射区的后面有一个4K的保护页面    。</p>
<p>不同的映射方式之间都会有一个空隙来起到保护作用。</p>
<p><strong>5. 写时拷贝机制</strong></p>
<p>写时拷贝机制的目的， 一是为了节约物理内存，二是为了加快创建进程的速度。</p>
<p>在使用fork（）生成新的进程时，新进程与原进程会共享同一内存区，这部分内存区是只读的， 当其中一个进程进行写操作时，系统才会为其另外分配内存页面。 这就是copy－on－write的概念。</p>
<p>当进程A使用系统调用fork来创建一个子进程B时， 由于子进程B实际上是父进程A的一个拷贝，因此会拥有与父进程相同的物理页面。也即为了达到节约物理内存和快速创建的目的，fork（）函数会让子进程B以只读方式共享父进程A的物理页面，同时父进程A对这些物理页面的访问权限也设置为只读（这是通过copy_page_tables()来实现的）。 这样以来，当父进程A或者子进程B，其中任何一方对这些共享页面执行写操作的时候， 都会产生page－fault，然后cpu会执行异常处理函数do_wp_page()来试图解决这个异常。</p>
<p>首先，会对这个物理页面取消共享， 然后为写进程复制一新的物理页面， 是父进程和子进程各自拥有一块内容相同的物理页面，这时才真正的进行了复制操作（当然是只复制这一个物理页面。），然后，将要执行写操作的这个物理页面置为可写的。 最后，从异常处理函数返回，cpu会重新执行刚才导致异常的写入操作指令，使进程能够执行下去。</p>
<p><strong>6. 伙伴分配算法</strong></p>
<p>这个没有深入研究过， 也没有在实际工作中遇到这方面的问题， 所以只知道一个大概。</p>
<p>&nbsp;</p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-07-29T00:00:00+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/250">
		
			三言两语聊kernel：线程栈</a>
	</h2>
	<div class="entry-content">
		<p>Oops! MacOS不支持proc文件系统，这或许是BSD系统最值得吐槽的地方吧。无奈只好到linux机器上写了这篇文章。</p>
<p>下面是一个比较简单的多线程程序。程序如下，<br />
<img src="/images/250.jpg"><br />
上图是我的测试程序，我创建了3个线程。程序运行以后，我们可以通过/ proc/<span class="caps">PID</span>/task来看该程序有多少线程在运行：<br />
<img src="/images/250-2.jpg"><br />
然后我们来看一下进程的地址空间。 /proc/<span class="caps">PID</span>/maps就是进程的地址空间。如下所示：<br />
<img src="/images/250-3.jpg"><br />
可以看出，进程的地址空间从低到高依次是：进程代码段(标志含有x)、只读数据段、可读写数据段、堆、栈（包括动态库的栈空间）。<br />
<div><br />
<div>    线程83438的栈：0xb7570000 &#8211; 0xb6d70000的值恰好是8M，线程栈默认大小是8M。0xb6d70000 &#8211; 0xb6d6f000的值是1K，这1K是保护页。</div><br />
<div>    为什么这三个线程的栈都是8M？可以从ulimit命令来得出，这是进程的资源限制：</div><br />
<img src="/images/250-4.jpg"><br />
<div>    使用ulimit <del>a命令可以看出，进程资源限制中栈大小的限制是8194K，即8M。</div><br />
<div>     那么，这个8M大小是不是可以更改的？以及后面会什么会有一个4K大小的保护页？这可以从glibc代码里面来获取答案：</div><br />
<div><br />
<div></div><br />
<div>       <strong><span style="color: #808000;">  1. </span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">__pthread_create_2_1</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        /<strong><a><span style="color: #808000;">这里分配线程栈</span></a></strong>/</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        ALLOCATE_STACK (iattr, &amp;pd); </span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">2. </span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">allocate_stack就是具体的分配线程栈的函数：</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">allocate_stack</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     <a><span style="color: #808000;">/<strong>如果没有设置线程栈大小，就使用默认值</span></a></strong>/</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     size = attr</del>&gt;stacksize ?: __default_stacksize;     </span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     &#8230;</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      /* Try to get a stack from the cache.  <strong>/</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      pd = get_cached_stack (&amp;size, &amp;mem);</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     /</strong>如果没有从cache申请到，就要mmap申请一块内存*/</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      if (pd == <span class="caps">NULL</span>){</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">           /<strong>MAP_PRIVATE | MAP_ANONYMOUS：私有匿名映射</strong>/</span></strong></div><br />
<div style="padding-left: 30px;"><strong><span style="color: #808000;">          mmap (<span class="caps">NULL</span>, size, prot,  </span></strong></div><br />
<p style="padding-left: 120px;"><strong><span style="color: #808000;">MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);   </span></strong></p></p>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      }</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     /*</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        接着设置一个保护区，该区域的页表属性是PROT_NONE,</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">        即Page can not be accessed</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">     */</span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">      mprotect (guard, guardsize, PROT_NONE) </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;"> </span></strong></div>
<div style="padding-left: 30px;"><strong><span style="color: #808000;">       对于设置为PROT_NONE的页，是不能访问的，那么访问到这个保护区时就出现错误，linux是靠这种机制来实现栈溢出保护的。</span></strong></div>
<div style="padding-left: 30px;"></div>
<div><span style="color: #000000;">    下面我们来调整线程栈：</span></div>
<div><span style="color: #000000;">   <strong> 1. 设置pthread_attr属性</strong></span></div>
</div>
<p><img src="/images/250-5.jpg"><br />
<div></div><br />
<img src="/images/250-6.jpg"><br />
<div><br />
<div>可以看到此时的线程栈大小是： 0xb758f000 &#8211; 0xb756f000 = 128K.</div></p>
</div>
<div>    <strong>2.通过ulimit来统一设置当前shell下将要执行的程序的线程栈 </strong></div>
<div>        ulimit -s  128</div>
<div>
<div>    要注意的是， ulimit -s是针对shell的设置， 即只对当前shell fork的进程有效。如果在另外一个shell上起进程，则是没有效果的。参见 man手册：“Control the resources available to a process started by the shell, on systems that allow such control.”</div>
</div>
<div></div>
</div>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-05-18T00:00:00+08:00" pubdate data-updated="true">May 18<span>th</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/227">
		
			2012 Memory</a>
	</h2>
	<div class="entry-content">
		<p><span>仅统计记录在案的，不过我看过的书和电影一般都会记录在豆瓣上，听过的音乐则比较多，只统计iPod里面听的次数较多的音乐。</span><br />
&nbsp;<br />
<h3>一 书</h3><br />
<table width="100%"><br />
<tbody><br />
<tr><br />
<th><strong>书名</strong></td><br />
<th><strong>豆瓣评分</strong></td><br />
<th><strong>我的评分</strong></td></p>
</tr>
<tr>
<td valign="top">佛祖在一号线</td>
<td valign="top">8.4</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">linux内核编程</td>
<td valign="top">无</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">unix环境高级编程</td>
<td valign="top">9.5</td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">1949年后的梁漱溟（港版）</td>
<td valign="top">7.3</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">捉虫日记</td>
<td valign="top">无</td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">冰与火之歌（卷一）</td>
<td valign="top">9.4</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">大话处理器</td>
<td valign="top">6.9</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">大江大海1949</td>
<td valign="top">无</td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">linux/unix设计思想</td>
<td valign="top">7.7</td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">底层中国的缓慢革命</td>
<td valign="top">无</td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">影像中的文革农村</td>
<td valign="top">无</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">这样事和谁细讲</td>
<td valign="top">无</td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">技术元素</td>
<td valign="top">8.4</td>
<td valign="top">3星</td>
</tr>
</tbody>
</table>
<div>5本技术类书籍，8本非技术类书籍（其中有5本是禁书）。</div>
<p>&nbsp;<br />
<h3>二 影（59部）</h3><br />
<div><br />
<table width="100%" border="1" cellspacing="0" cellpadding="2"><br />
<tbody><br />
<tr><br />
<th valign="top">电影/电视名</td><br />
<th valign="top">豆瓣评分</td><br />
<th valign="top">我的评分</td></p>
</tr>
<tr>
<td valign="top">亡命驾驶</td>
<td valign="top"><span style="color: #97248d;">7.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">三傻大闹宝莱坞</td>
<td valign="top"><span style="color: #053df5;">9.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">93航班</td>
<td valign="top"><span style="color: #97248d;">7.6</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">飞天大盗（第一季）</td>
<td valign="top"><span style="color: #ac784a;">8.9</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">锅匠、裁缝、士兵、间谍</td>
<td valign="top"><span style="color: #97248d;">7.8</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">总统杀局</td>
<td valign="top"><span style="color: #ff9132;">6.9</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">点球成金</td>
<td valign="top"><span style="color: #ac784a;">8.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">夺命金</td>
<td valign="top"><span style="color: #97248d;">7.1</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">谍中碟4</td>
<td valign="top"><span style="color: #ac784a;">8.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">龙门飞甲</td>
<td valign="top"><span style="color: #ff9132;">6.8</span></td>
<td valign="top">2星</td>
</tr>
<tr>
<td valign="top">我愿意</td>
<td valign="top"><span style="color: #ff1e18;">5.6</span></td>
<td valign="top">2星</td>
</tr>
<tr>
<td valign="top">齐达内：21世纪的肖像</td>
<td valign="top"><span style="color: #97248d;">7.4</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">战马</td>
<td valign="top"><span style="color: #97248d;">7.8</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">抢钱大作战</td>
<td valign="top"><span style="color: #97248d;">7.5</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">胡佛</td>
<td valign="top"><span style="color: #97248d;">7.0</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">一次别离</td>
<td valign="top"><span style="color: #ac784a;">8.8</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">兵临城下之决战要塞</td>
<td valign="top"><span style="color: #97248d;">7.6</span></td>
<td valign="top">2星</td>
</tr>
<tr>
<td valign="top">异星战场</td>
<td valign="top"><span style="color: #ff9132;">6.0</span></td>
<td valign="top">1星</td>
</tr>
<tr>
<td valign="top">晚秋</td>
<td valign="top"><span style="color: #ff9132;">6.6</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">春娇与志明</td>
<td valign="top"><span style="color: #97248d;">7.3</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">规则改变</td>
<td valign="top"><span style="color: #ac784a;">8.0</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">十加十</td>
<td valign="top"><span style="color: #97248d;">7.0</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">桃姐</td>
<td valign="top"><span style="color: #ac784a;">8.3</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">超级战舰</td>
<td valign="top"><span style="color: #ff9132;">6.5</span></td>
<td valign="top">1星</td>
</tr>
<tr>
<td valign="top">赛德克巴莱（上）</td>
<td valign="top"><span style="color: #ac784a;">8.7</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">复仇者联盟</td>
<td valign="top"><span style="color: #ac784a;">8.0</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">赛德克巴莱（下）</td>
<td valign="top"><span style="color: #ac784a;">8.4</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">赛德克巴莱（大陆版）</td>
<td valign="top"><span style="color: #ac784a;">8.5</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">黄金大劫案</td>
<td valign="top"><span style="color: #ff9132;">6.7</span></td>
<td valign="top">2星</td>
</tr>
<tr>
<td valign="top">北京爱情故事</td>
<td valign="top"><span style="color: #97248d;">7.3</span></td>
<td valign="top">1星</td>
</tr>
<tr>
<td valign="top">马达加斯加3</td>
<td valign="top"><span style="color: #ac784a;">8.3</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">画皮2</td>
<td valign="top"><span style="color: #ff1e18;">5.7</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">抓住外国佬</td>
<td valign="top"><span style="color: #97248d;">7.1</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">搜索</td>
<td valign="top"><span style="color: #97248d;">7.1</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">突袭</td>
<td valign="top"><span style="color: #97248d;">7.4</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">神探亨特张</td>
<td valign="top"><span style="color: #ff9132;">6.5</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">慕尼黑</td>
<td valign="top"><span style="color: #97248d;">7.6</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">麦兜当当伴我心</td>
<td valign="top"><span style="color: #ac784a;">8.3</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">精英部队2</td>
<td valign="top"><span style="color: #ac784a;">8.8</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">麦兜故事</td>
<td valign="top"><span style="color: #ac784a;">8.5</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">普罗米修斯</td>
<td valign="top"><span style="color: #97248d;">7.1</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">蝙蝠侠：黑暗骑士崛起</td>
<td valign="top"><span style="color: #ac784a;">8.4</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">浪潮</td>
<td valign="top"><span style="color: #ac784a;">8.7</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">飓风营救</td>
<td valign="top"><span style="color: #ac784a;">8.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">飓风营救2</td>
<td valign="top"><span style="color: #ff9132;">6.4</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">两杆大烟枪</td>
<td valign="top"><span style="color: #053df5;">9.1</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">从海底出击</td>
<td valign="top"><span style="color: #ac784a;">8.9</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">谍影重重4</td>
<td valign="top"><span style="color: #ff9132;">6.7</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">英国病人</td>
<td valign="top"><span style="color: #ac784a;">8.4</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">触不可及</td>
<td valign="top"><span style="color: #053df5;">9.0</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">莫扎特传</td>
<td valign="top"><span style="color: #ac784a;">8.6</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">汉密尔顿：国家利益</td>
<td valign="top"><span style="color: #ff9132;">6.5</span></td>
<td valign="top">5星</td>
</tr>
<tr>
<td valign="top">泰迪熊</td>
<td valign="top"><span style="color: #97248d;">7.0</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">加菲猫</td>
<td valign="top"><span style="color: #97248d;">7.4</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">少年派的奇幻漂流</td>
<td valign="top"><span style="color: #053df5;">9.1</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">我在伊朗长大</td>
<td valign="top"><span style="color: #ac784a;">8.7</span></td>
<td valign="top">4星</td>
</tr>
<tr>
<td valign="top">寒战</td>
<td valign="top"><span style="color: #97248d;">7.5</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">人在囧途之泰囧</td>
<td valign="top"><span style="color: #97248d;">7.9</span></td>
<td valign="top">3星</td>
</tr>
<tr>
<td valign="top">车轮不息</td>
<td valign="top"><span style="color: #053df5;">9.2</span></td>
<td valign="top">5星</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<div>59部电影中，</div>
<div>豆瓣评分超过9分的：5部</div>
<div>豆瓣评分8~9的： 21部</div>
<div>豆瓣评分7~8的：22部</div>
<div>豆瓣评分6~7的：10部</div>
<div>豆瓣评分5~6的：2部（这两部都是在影院看的）</div>
<div>最低分：我愿意（5.6）</div>
<div>最高分：车轮不息（9.2）</div>
<div></div>
<div></div>
<div>我的评分：</div>
<div>5星： 12部</div>
<div>4星： 21部</div>
<div>3星： 20部</div>
<div>2星： 4部</div>
<div>1星： 3部（两部在影院看的科幻片，1部电视剧）</div>
<div></div>
<div>在影院看的：20部</div>
<p>&nbsp;<br />
<div></div><br />
<h3>三 音（Top39）</h3><br />
<div><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--><br />
<div>这39首歌曲中：</div><br />
<div>纯音乐：20首</div><br />
<div>摇滚： 8首</div><br />
<div>影视原声：6首</div><br />
<div>粤语：3首</div><br />
<div>国语：3首</div><br />
<div>英语：11首</div></p>
</div>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-01T00:00:00+08:00" pubdate data-updated="true">Jan 1<span>st</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/215">
		
			三言两语聊Kernel： Undefined Instruction</a>
	</h2>
	<div class="entry-content">
		<p><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->    在写这篇文章的时候，我一直在犹豫要不要写， 因为它涉及到我的日常工作，而我司对信息安全监管的特别严。但是，我觉得最近遇到的这个bug确实很有趣，有必要记录一下，以后翻阅的时候也有参考。 所以，我禁掉了google对我个人博客的搜索，同时也关掉了往其他博客（比如sina微博）的同步。权当做个人记录。<br />
<div>     一个可执行文件，简单的看就是指令和数据的集合。 CPU在执行该可执行文件的时候，会不断的去读取指令，然后解析该指令，最终执行，这是流水线的基本原理。</div><br />
<div></div><br />
<div>    Undefined Instruction的意思就是，CPU无法解析从内存中读取到的指令，这条指令不是该CPU能够识别的指令集里面的。 出现undefined instruction，无非是以下几种情况：</div><br />
<div style="padding-left: 30px;">1）确实是非法指令</div><br />
<div style="padding-left: 60px;">这种情况一般都是硬编码导致，在代码里直接用16进制的数字来表示一条指令，这样就导致这些代码移植到其他平台的时候不能被解析。</div><br />
<div style="padding-left: 30px;">2）踩内存</div><br />
<div style="padding-left: 60px;">存储指令的内存空间被踩掉，指令就变成了其他的内容，这种情况，出现什么错误都是有可能的。不仅仅是undefined instruction，还可能是bad syscall等等。</div><br />
<div style="padding-left: 30px;">3）指令所在的内存被释放掉</div><br />
<div style="padding-left: 60px;">这种情况一般都是出现在操作系统里面。在操作系统初始化的时候，会执行很多初始化代码，这些代码在操作系统起来后就再也不被执行到了。为了节省内存，os就有了个机制：回收初始化代码，或者说，free init memory。一个函数使用__init memory机制的前提是，作者认为这部分代码以后永远也不会被用到。ok，问题就来了。 原作者很清楚自己写的代码，而后来的维护者就理解不是很深刻，他就可能会调用到__init memory里面的代码。可想而知，这必然是会出错的，因为init memory已经被释放然后分配给其他用途了，这个地址空间不知道存储的是什么东西，你再到这个地址空间去取指令，显然发生的错误是不可预料的。</div><br />
<div></div><br />
<div>    这三种情况我都有遇到过。 从定位问题的难度来看，感觉第3种是最好定位的，第2种是最不好定位的.下面我要说的就是遇到的第3种情况的问题。</div><br />
<div></div><br />
<div>    我在移植一个特性到os上去，执行的时候出现undefined instruction的情况，每次都是在func_a()这个出现。我就去看func_a()的反汇编，那个地址对应的指令是正常的。于是，我猜测应该是踩内存了。</div><br />
<div></div><br />
<div>    接下来，我在调用func_a()的前面加了几行语句，来把func_a()所在地址空间里面的内容给打印出来，看看到底是哪里被踩了。</div><br />
<div style="padding-left: 30px;">/<strong>打印出从func_a()所在地址开始的25条语句</strong>/</div><br />
<div style="padding-left: 30px;">for(i = (unsigned int)func_a; i &lt; (unsigned int)func_a + 100; i += 4 )</div><br />
<div style="padding-left: 30px;">     printk(&#8220;%08x : %08x\n&#8221;, (unsigned int)func_a, *(unsignd int *)func_a);</div><br />
<div></div><br />
<div>    打印出来的数据显示，func_a()这个函数里面的内容都被踩掉了。于是就去研究，为什么被踩。</div><br />
<div></div><br />
在追内核代码的过程中，发现func_a()这个函数其实是初始化部分的函数。函数定义如下：<br />
<div class='bogus-wrapper'><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">__init</span> <span class="nf">func_a</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></div><br />
   __init这个宏的定义如下：<br />
<img src="/images/215.jpg"><br />
它的作用是，将这个函数放到.init.text这个section中。section是elf格式的一个概念，具体可google之。 os是怎么处理.init.text这个section的哪？<br />
<div></div><br />
    在free_initmem()这个函数里面会将这个section所占用的内存给释放掉：<br />
<img src="/images/215-2.jpg"><br />
注释：<br />
<div>1） __init_begin和__init_end的的初始化是在vmlinux.lds.S这个文件里面。 INIT_TEXT_SETION位于这两个变量之间。</div><br />
<div>2）INIT_TEXT_SETION的定义是在include/asm-generic/vmlinux.lds.h这个头文件中，就是.init.text这个节。</div><br />
<div></div></p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-01T00:00:00+08:00" pubdate data-updated="true">Jan 1<span>st</span>, 2013</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/197">
		
			三言两语聊Kernel：flash驱动及文件系统</a>
	</h2>
	<div class="entry-content">
		<p style="text-align: left;">    flash分为nor flash和nand flash。nor flash的容量较小，但访问速度相对快；nand flash的容量较大。</p>
<p style="text-align: left;">    用户访问flash的内容大概是要经历这些过程：<br />
用户-＞vfs-＞具体文件系统-＞mtd设备（字符设备、块设备）-＞cfi命令字-＞flash。</p>
<p style="text-align: left;">    现在的flash一般都满足cfi标准，对于不满足cfi标准的flash要使用其他的命令字。</p>
<p>flash空间可根据需要来灵活划分分区，比如32M的flash，做如下划分：1M(uboot),2M(kernel),4M(initrd),25M(log)。注意划分分区的大小必须要是block大小的整数倍。分区划分可以通过uboot传参的方式来做， 这样更灵活一些，当然也可以直接写死在内核里面。使用uboot传参的方式需要内核mencuonfig的支持，即打开开关：CONFIG_CMDLINE_PARTS。打开了这个开关后，内核启动时就会解析uboot传递的参数：&quot;mtdparts=nor:1M(uboot),2M(kernel),4M(initrd),25M(log)&quot;。在内核启动时，只是会将这些分区划分信息给存储起来， 只有真正的加载flash驱动后，即通过cfi probe具体的flash并加载其ko，然后在会读取分区划分信息并对flash空间进行划分。划分好分区后，通过/proc/mtd可以看到这些分区。同时在/dev目录下能够看到对应的mtd设备（包括块设备和字符设备），由于我们是划分的4个分区，所以可以看到mtd0、mtd1、mtd2、mtd3这四个设备。我们可以通过open这几个设备来读写对应的flash地址空间。例：<br />
<div class='bogus-wrapper'><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/mtd3&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="err">“</span><span class="n">open</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">LEN</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="err">“</span><span class="n">write</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="err">“</span><span class="n">close</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nl">error:</span>
</span></code></pre></td></tr></table></div></figure></div></p>
<div>    通过mtd设备赖读写flash，这种方式会绕过文件系统层，即直接通过mtd接口来读写。这种方式和dd命令读写块设备是一致的，dd命令本质上也是用的这种方式， 比如我要随即产生1M大小的内容写入到mtd3对应的地址空间中可以这样：</div>
<div style="padding-left: 30px; text-align: center;">dd if=/dev/urandom of=/dev/mtdblock3 bs=128k count=8</div>
<div style="padding-left: 30px;"></div>
<div>     dd命令一般是用来测试flash的读写速度。</div>
<div style="text-align: left;">    上述这种方式，在内核里的执行路径大概是这样子：<br />
vfs_read/vfs_write-&gt;part_read/part_write-&gt;cfi_amdstd_read/do_write_buffer.</div>
<div style="text-align: left;">这种方式会绕过flash的具体文件系统，而是从vfs直接到mtd层。</div>
<div style="text-align: left;"></div>
<p>读写flash当然也可以使用/dev/mem的方式，/dev/mem是将外设的空间当做一块内存，然后mmap出来，这样就能直接在用户空间来操作物理地址。使用/dev/mem的示例如下：<br />
<div class='bogus-wrapper'><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">mem</span><span class="err">”</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_SYNC</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="err">“</span><span class="n">open</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">map_base</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">((</span><span class="n">map_base</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FLASH_SIZE</span><span class="p">,</span>  <span class="n">PROC_READ</span><span class="o">|</span><span class="n">PROC_WRITE</span><span class="p">,</span>
</span><span class='line'>            <span class="n">MAP_SHARED</span><span class="p">,</span>  <span class="n">fd</span><span class="p">,</span> <span class="n">FLASH_BASE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="err">“</span><span class="n">mmap</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* get the content of the flash */</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FLASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">map_base</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></div></p>
<p>使用/dev/mem的这种方式，不会调用驱动接口，它是直接把flash当做一块内存来使用，所以 /dev/mem这种方式破坏性很大。<br />
<div></div><br />
<div>     flash文件系统，现在主流的有jffs2、yaffs2、ubifs。jffs2适用于nor flash，yaffs2适用于nand flash，ubifs两种flash都适用。yaffs2目前还未进入内核主线。jffs2则很早就进入了内核主线，且在业界有相对较广泛的应用。ubifs是比较新的文件系统，在性能上显著优于其余两者，不过稳定性上目前还不太好。这三种flash文件系统各自的邮件列表貌似都不太活跃，通常是好几天才能收到一封邮件：）</div><br />
<div></div></p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-12-16T00:00:00+08:00" pubdate data-updated="true">Dec 16<span>th</span>, 2012</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/180">
		
			《捉虫日记》书评</a>
	</h2>
	<div class="entry-content">
		<p style="text-align: left;">    对于苦逼的IT男而言，对下面这个场景应该感到亲切。发出去的软件版本出现了bug，事情很紧急，于是大佬召集所谓一堆专家头脑风暴寻求解bug的思路，各路专家你一言我一语各抒己见，最终在众人齐心协力下，终于在最后关头定位出了根因。没有解不了的bug，只有不努力的coder。</p>
<p style="text-align: left;">    然而这个世界上还有另外一种人，他们也是解bug，只不过是找别人软件中的bug，他们通常被我们称之为hacker。</p>
<p style="text-align: left;">    同样是解bug，主动去找的就被称为黑客，被称作漏洞攻击，是人人都崇拜的行为艺术，就像街头弹吉他的青年歌手一样；而被动去定位的则被称为IT码农，被称作问题攻关，是人人都摇头的养家糊口，就像路边上拉二胡的老人一样。所以，不同的心态就会有不同的境界。凡事都要主动的好，这跟追女孩子是一个道理，美女身边有那么多人在追她，你不努力，美女怎么可能会想起你来哪？当然，你努力了，美女也未必会想起你来 ：）</p>
<p>    《捉虫日记》这本书的作者Tobias Klein就是那种可以被称之为hacker的人。作者热衷于找各个os的bug，这本书描述了作者找到的7个bug，他详细的记录了如何去寻找bug，以及如何利用这个bug，当然他也给出了每个bug的解决方案。像作者这种hacker，或者说geeker，应该会有twitter的，于是我翻墙搜了下，他的确开通了twitter，twitter账号是 @ tobiklein ，虽然作者是德国人，可是所发推文都是英文。可见，要想在twitter这个世界混的好，就得学会用英文，否则就只能在自己那个狭窄的母语圈来混了。而中文推特圈，则以狭隘、偏激而著称，至于原因，你懂的。Tobias Klein在10年3月31日发了一条推文“My new book just got released!”，指的就是这本书。至今为止Tobias Klein所发推文不多，从他的推文可以看出，他现在应该主要在研究iOS的bug。</p>
<p>下面是作者这本书里面7个例子的大致介绍。<br />
<p style="padding-left: 30px;">作者讲的第一个例子是个典型的栈缓冲区溢出（stack overflow）的例子。下面是个简单的stackoverflow示例程序。</p><br />
<p style="padding-left: 60px;"><strong>／*stackoverflow.c*／<br />
</strong><span style="color: #808000;">void overflow(char *argc)</span><br />
<span style="color: #808000;"> {    </span><br />
<span style="color: #808000;">    char buff<sup class="footnote" id="fnr8"><a href="#fn8">8</a></sup>;</span><br />
<span style="color: #808000;">     strcpy(buff, argc);</span><br />
<span style="color: #808000;"> }</span></p><br />
<p style="padding-left: 60px;"><span style="color: #808000;"> int main(int argc, char *argv[])</span><br />
<span style="color: #808000;"> {</span><br />
<span style="color: #808000;">     if(argc &gt; 1){</span><br />
<span style="color: #808000;">         overflow(argv<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>);</span><br />
<span style="color: #808000;">     }</span><br />
<span style="color: #808000;">     return 0;</span><br />
<span style="color: #808000;">  }</span></p><br />
<p style="text-align: left;">     对于上面这个简单的程序，如果我们输入的数据长度大于8，就会发生栈缓冲区溢出。这里涉及的知识点有栈桢、数组。注意在linux下使用gcc来编译时要禁用gcc的堆栈保护才会stackoverflow，使用-fno-stack-protector编译选项。作者在twitter上也提到了几个stack overflow的bug，是iOS和MacOS的。看来栈缓冲区溢出这个bug太容易犯了，因为字符串操作函数strcpy()和strcat()很容易导致出错。这也是很多hacker热衷于寻找的一类bug。</p><br />
<p style="text-align: left;">    作者讲的第二个例子是solaris内核中内核态和用户态接口的一个bug。作者一直喜欢寻找操作系统内核漏洞，所以就拿solaris来开刀了，为什么不选择linux kernel哪？linux使用的人多，影响又大，而solaris则日薄西山了。对于操作系统而言，内核／用户态接口是最容易产生漏洞的地方。这些接口主要是以下几种：<br />
1）  ioctl<br />
2）  syscall<br />
3）  文件系统网络协议栈<br />
4）  第三方ko注册的钩子</p><br />
<p style="text-align: left;">    作者发现的一个bug是ioctl的bug。</p><br />
<p style="text-align: left;">    作者讲的第三个例子是空指针的一个bug。对于空指针，我想起一些工作上的事。有些新手经常问如何简单的让linux内核panic，我告诉他们访问一个null指针就好了。过了会，他们给我说，访问空指针的结果是segment fault，不是panic。我只好无奈的再解释，要写个ko，在内核态往null地址写数据就panic了，用户态出错，最多进程被杀死，是不会导致系统崩溃的。</p><br />
<p style="text-align: left;">    作者讲的第四个例子是浏览器ActiveX控件的一个bug。我对windows编程不太熟悉，此例不多言。</p><br />
<p style="text-align: left;">    作者讲的第五个例子是windows驱动的bug。用作者自己的话说，他想看看能不能在非开源的系统（比如windows）上找到bug。作者还特意把枪口瞄向了杀毒软件，真是大水冲龙王庙，自家人不认自家人啊。最终作者还真找到了bug，并通知给了杀毒软件厂商，他们及时的做了修复。</p><br />
<p style="text-align: left;">    第六个例子是MacOS的一个bug，看来作者是要通吃所有的操作系统啊。怪不得作者不找linux的麻烦，是嫌降低自己的身份啊！这个MacOS的bug依然是ioctl的bug，看来作者认定了所有os的ioctl都会有bug。</p><br />
<p style="text-align: left;">    最后一个例子是作者寻找iPhoneOS的bug，好吧，你赢了，你是真正的内核hacker。我只是一个内核码农，还只略微懂点linux的。</p><br />
<p style="text-align: left;">    虽然作者针对的是每个os的bug，但是这些bug都是最基础的编程问题。一招鲜吃遍天，只要你编程能力强，通吃所有的os只是你愿不愿意的问题。</p><br />
<p style="text-align: left;">    至于这本书的翻译，张伸，他也有twitter账号（@loveisbug），他竟然也是个足球迷。看在他是足球迷的份上，好吧，这本书翻译的挺好的。</p><br />
<p style="text-align: left;">    本来我是打算follow一下这位译者的，后来看到了它的一个推文，就不打算follow他了。他的推文是：“请教，a backtrace of all stack frames是什么意思？backtrace是函数调用栈吗？”。在这里回答译者一下：</p><br />
<p style="text-align: left;">    一个函数调用可以称之为一个栈帧，backtrace就是栈帧的集合，也就是函数调用栈。而缓冲区溢出（stack overflow）利用的的基本原理就是栈帧。使用gdb的bt命令就能够看出当前函数的调用栈。</p></p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-10-03T00:00:00+08:00" pubdate data-updated="true">Oct 3<span>rd</span>, 2012</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/119">
		
			iPhoneOS浅浅浅浅析(4):不做学术派</a>
	</h2>
	<div class="entry-content">
		<p><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->     回顾了一下我的前三篇文章，基本可以用这句话来概括：“我觉得这个问题可以怎么怎么样，但是我没搞定，当然，如果有时间有精力我一定能搞定”。这是典型的学术派思维。对于那些只说话不做事的“专家”而言，确实可以这说，但是对处于食物链底层的我等码农们而言，这是很不可取的。对于码农们而言，做要比说更重要，而不是那些天马行空的思维。对于专家们而言，则是说比做要重要。这个次序万万不可搞反了，不然下场会很惨。<br />
<div>     我现在天天研究iPhoneOS怎么样，MacOS又怎么样，整天一副自以为是的样子来指点江山</p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-05-20T00:00:00+08:00" pubdate data-updated="true">May 20<span>th</span>, 2012</time></div>
	<div class="tags">

</div>
	
</div>
</article>  


   <article class="post">
	<h2 class="title">
		
		<a href="/blogs/112">
		
			iPhoneOS浅浅浅浅析（3）</a>
	</h2>
	<div class="entry-content">
		<p><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->     由于某司太过信息安全，当然我更多的是出于职业道德的考虑，既然拿了老板的钱，就要给老板赚钱，就不要损害老板的利益。所以，在我的个人博客上的技术文章从未涉及到我周一至周五每天早上9点至晚上八点四十埋头苦思的内容。这就好比，在武林大会上，一个剑客偏偏不能使剑，威力自然是大大打了折扣。所以，我这里的技术文章都显得很是小儿科，不要见怪。<br />
<div>     我这个系列叫做《iPhoneOS浅浅浅浅析》，但是，你会发现，这里面的内容和iPhone真是八竿子打不着。嗯，这个系列其实是写的mac，但是，你懂得，要标题党，不然吸引不了您的关注。呼呼。</div><br />
<div>     这篇文章就轻松愉悦一些。说一说mac一些很好玩的东西。</div><br />
<div>     众所周知，mac的应用程序比较匮乏，其娱乐性及实用性均被windows给甩出了几条街，其相比于windows唯一的优势便是它的标新立异，这也是我买mac的主要原因，好奇、新鲜感。其实用性差的地方不胜枚举，比如，我要通过网银给我妈寄钱，可惜没有mac下的网银客户端，没办法，只能打开我的thinkpad了。在日常娱乐中给我很不爽的是，下载电影很不方便，由于mac的浏览器是safari，我最常用的下载网站goxiazai就只能通过迅雷来下载电影，而该网站又不支持非IE内核调用迅雷。于是，我只好使用我的thinkpad下载电影，然后在mac上通过samba服务来访问thinkpad，然后使用mplayer来看下载的电影，在mac上看电影还是很炫的说。</div><br />
<div>     综上所述，不难发现，windows就像老婆，是每个男人必备的，而mac就像是小蜜，只能用来调剂情操。你可能觉得小蜜很是讨你欢心，但是关键时刻还得靠你老婆。</div><br />
<div>     既然mac电脑有如此多的粉丝，自然有它与众不同的地方。mac的touchpad就很个性化，它的touchpad是这样子的：</div><br />
<div><img src="webkit-fake-url://8B196E7A-8C0C-4FB3-BC01-E60AD10ED593/image.tiff" alt="" /></div><br />
<div>mac的touchpad仅仅是一个面板，没有左右按键，也没有侧边滑动框。简洁的才是最好的，这句话在这得到很充分的体现。虽然它没有这些东西，然而并不妨碍它有这些功能，mac用软件的方式来实现了在windows下需要硬件来完成的功能，而且，你一点也不会觉得麻烦，你会觉得使用起来非常的舒服。mac的touchpad是支持多点触摸的，两个手指同时按下就实现了鼠标右键的功能，两个手指同时滑动就实现了滑动的功能。它最多可以支持4个手指同时滑动，这也是很合理的，一个touchpad最多也就只能同时容纳四个手指嘛，四个手指同时滑动的效果就是misson control的功能。估计这种touchpad被apple申请了专利，所以windows机器才会使用那么丑陋的touchpad吧。</div><br />
<div>     mac电脑让我使用的最舒服的地方是它的misson control功能，就是F3按键的功能。我在电脑做一件事件时一般都是全屏操作，而有时候打开了很多东西，需要来回的切换，miss control就很方便的实现了我的这个需要。也许你会说windows的alt+tab同样可以，嗯，确实可以，不能否认比亚迪和兰博基尼都是汽车、都能开。</div><br />
<div>     对于技术宅没来说，mac最大的优点还是它的shell，yeah，你可以像linux一样使用mac。mac使用的是BSD的内核，和linux一样，都是由unix发展来的，所以mac和linux有很多相通的地方。MacOS的内核是darwin，darwin是一个混合内核，包括Mach 3微内核和FreeBSD组件。</div><br />
<div>    <a href="http://www.laoar.net/wp-content/uploads/2012/05/macos.jpg"><img class="alignnone size-full wp-image-114" title="macos" src="http://www.laoar.net/wp-content/uploads/2012/05/macos.jpg" alt="" width="441" height="220" /></a></div><br />
<div>Mach 提供了操作系统最重要的部分，它管理处理器资源比如CPU的使用、内存、调度、内存保护以及以消息传递为核心的进程间通信基础设施。 Darwin提供了一个面向对象的框架用来开发设备驱动，这个框架叫做I/O Kit. Darwin对BSD的应用包括很多POSIX API，上层应用程序可以通过这些接口来实现基本的应用程序功能。BSD为MacOS X的文件系统和网络设施提供基础的服务。<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></div><br />
<div>     简单说下Darwin的历史。Darwin于1989年由NeXT公司发布（源码由Apple公司在2000年公开）。Darwin继承自NeXTSTEP（后来的OPENSTEP）操作系统。然而NeXT公司经营状况并不乐观，在1996年12月Apple花费4亿美金买下NeXT，Apple想要用NeXTStep来构成一个新的现代操作系统的基础，因为Apple当时的操作系统差得每当启动Netscape的Navigator的时候都会崩溃。从此NeXT技术进入Apple。Mac OS X Server 1.0应该才是开始以Darwin为核心开发的操作系统。</div><br />
<div>     Darwin有一个开源版本叫做OpenDarwin，OpenDarwin的计划是要为开源开发者提供资源来进行与Mac OS X的互动并为其生产产品。这个项目的其中一个主要方面就是使对Mac OS X感兴趣的开发者能够得到，修改，build并分发操作系统的变化。但是OpenDarwin这个项目最终over了，因为没有开发者参与进来。与此同时，GNU Darwin项目仍然继续。它的目标是创建一个基于Darwin的与Mac OS X兼容的操作系统，而不使用像CoreAudio 和CoreVideo这样的Mac OS X私有库.</div><br />
<div><span style="color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif, 宋体;">     Darwin源码是用svn进行管理的，其地址为：</span><a href="http://svn.macosforge.org/repository/darwinbuild/trunk/">http://svn.macosforge.org/repository/darwinbuild/trunk/</a> 。 使用svn co <a href="http://svn.macosforge.org/repository/darwinbuild/trunk/"><span style="color: #000000;">http://svn.macosforge.org/repository/darwinbuild/trunk/</span></a> 将其check到本地后，会发现它是一个xcode工程。使用xcode将其打开后如下所示：</div><br />
<div><a href="http://www.laoar.net/wp-content/uploads/2012/05/xcode.png"><img class="alignnone size-full wp-image-115" title="xcode" src="http://www.laoar.net/wp-content/uploads/2012/05/xcode.png" alt="" width="271" height="260" /></a></div><br />
<div>      <img src="file:///Users/apple/Library/Application%20Support/Evernote/data/101370/content/p44/6623446244f97c3e00f52d67afd1d6d5.png" alt="" /></div><br />
<div>具体分析，详见下回分解&#8230;</div><br />
<div> </div><br />
<div><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup><a href="https://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/OSX_Technology_Overview/SystemTechnology/SystemTechnology.html">https://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/OSX_Technology_Overview/SystemTechnology/SystemTechnology.html</a></div><br />
<div> </div></p>
		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-05-13T00:00:00+08:00" pubdate data-updated="true">May 13<span>th</span>, 2012</time></div>
	<div class="tags">

</div>
	
</div>
</article>  

<nav id="pagenavi">
    
        <a href="/blog/page/2/" class="prev">Prev</a>
    
    
        <a href="/blog/page/4/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>

&#8211;>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    Yafang Shao

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'laoar';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>